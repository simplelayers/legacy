<?php
use utils\ParamUtil;
/**
 * Viewer: Purge a ProjectLayer's ColorScheme, replacing it with one generated by a recipe.
 * Set the ProjectLayer's ColorScheme to a quantile scheme.
 *
 * Parameters:
 *
 * layer -- The unique ID# of the layer.
 *
 * project -- The unique ID# of the project.
 *
 * ruleset -- A block of XML representing the colorscheme's ruleset. See below for an example.
 *
 * Return:
 * Either an error, or the xml sent with an updated color scheme node.
 *
 * The XML string represents a color scheme in its entirety, both the recipe and the actual rules (criteria, color choices, etc.)
 * An example of the XML is as follows:
 * {@example docs/examples/viewercolorschemesave.xml}
 *
 * Example Input:
 * <layer id="368" type="projectLayer" name="saved_polys" owner="flashuiguy" geom="polygon" access="3" opacity="1" layer_on="1" search_on="1" bbox="-121.010154724121 34.6311073303223 -118.557266235352 40.259578704834" sharing="0">
 * <tags/>
 * <labels attribute="data2" labels_on="0"/>
 * <tooltip tooltip_on="1"><![CDATA[[url]
 * [data1]
 * [url]]]></tooltip>
 * <classification type="single" stroke_color="00ff00" fill_color="trans" symbol="hatch_right" symbol_size="5" attribute="name"/>
 * <colorscheme>
 * <rule crid="31924" priority="1" fill="trans" stroke="00ff00" field="" operator="" value="" symbol="hatch_right" size="5" _action="0"/>
 * </colorscheme>
 * </layer>
 *
 *
 * @package ViewerDispatchers
 */
function _config_save()
{
    $config = Array();
    WAPI::DecorateConfig($config);
    return $config;
}

function _headers_save()
{
    WAPI::SetWapiHeaders();
}

/**
 *
 * @ignore
 *
 *
 *
 *
 */
function _dispatch_save($template, $args)
{
    $world = $args['world'];
    $user = SimpleSession::Get()->GetUser();
    $wapi = $world->wapi;
    
    $request = $_REQUEST;
    // Step 0: Setup dependent variables and make sure the action is allowed.
    
    $projInfo = ($wapi->RequireProject());
    
    // load the project and make sure it's a vector layer
    $layerProperties = WAPI::GetInputXML();
    
    $denied = "&status=NO&{$_SERVER['QUERY_STRING']}&";
    $parent = WAPI::GetParam('parent', null);
    $isDefault = WAPI::GetFlagParam('asdefault', false);
    
    /* @var $projectLayer ProjectLayer */
    $projectLayer = $wapi->RequireProjectLayer();
    
    $project = ParamUtil::Get($args, 'project');
    $project = Project::Get($project);
    
    $layer = $wapi->layer;
    $targetLayer = $isDefault ? $layer : $projectLayer;
    // $targetLayer = $projectLayer;
    
    $isProjectLayer = is_a($targetLayer, 'ProjectLayer');
    
    // Is the request trying to save the colorscheme as the layer's default colorscheme?
    // if so, they need to own it, not just have edit permission
    if ($isDefault && ($layer->owner->id != $user->id)) {
        if ($layer->getPermissionById($user->id) < AccessLevels::EDIT) {
            $wapi->HandleError(new Exception(DENIED_NEEDEDIT));
        }
    }
    if ($isProjectLayer) {
        if ($project->getPermissionById($user->id) < AccessLevels::EDIT) {
            $wapi->HandleError(new Exception(DENIED_NEEDEDIT));
        }
    }
    // Step1 1: Store general layer properties
    $isRaster = false;
    if (($layer->type != LayerTypes::VECTOR) and ($layer->type != LayerTypes::RELATIONAL) and ($layer->type != LayerTypes::ODBC)) {
        $isRaster = true;
    }
    $searchable = null;
    $labels_on = null;
    $labelitem = null;
    $tooltip_on = null;
    $tooltip = null;
    if ($isDefault) {
        $opacity = $projectLayer->opacity;
        $on_by_default = $projectLayer->on_by_default;
        if (! $isRaster) {
            $searchable = $projectLayer->searchable;
	    $labels_on = $projectLayer->labels_on;
            $labelitem = $projectLayer->labelitem;
            $tooltip_on = $projectLayer->tooltip_on;
            $tooltip = $projectLayer->tooltip;
            $layer->label_style = $projectLayer->label_style_string;
        }
    } else {
        $opacity = $layerProperties['opacity'];
        $on_by_default = '' . $layerProperties['layer_on'] == "1";
        if (! $isRaster) {
            $searchable = '' . $layerProperties['search_on'] == '1';
            $labels_on = '' . $layerProperties->labels['labels_on'] == "1";
            $labelitem = '' . $layerProperties->labels['attribute'];
            $tooltip_on = '' . $layerProperties->tooltip['tooltip_on'];
            $tooltip = '' . $layerProperties->tooltip;
            $labelStyle =$layerProperties->labels->label_style;
            $targetLayer->label_style = html_entity_decode($labelStyle);
        }
    }
    if(isset($tooltip)) {
	$tooltip = str_replace('&gt;','>',$tooltip);
        $tooltip = str_replace('&amp;','&',$tooltip);
        $tooltip = str_replace('&quot;','"',$tooltip);
        $tooltip = str_replace('&apos;',"'",$tooltip);
        $tooltip = str_replace('&lt;','<',$tooltip);
    } 
    $targetLayer->opacity = $opacity;
    $targetLayer->on_by_default = $on_by_default;
    // Step 1.1 there's not much more to do if we have a raster type so just return the layer properties data.
    if ($isRaster) {
        print $layerProperties->asXML();
        return;
    }
    
    if ($isProjectLayer)
        $targetLayer->searchable = $searchable;
        
        // Step 2: Store label info
    $targetLayer->labels_on = $labels_on;
    $targetLayer->labelitem = $labelitem;
    
    
    
    
    // Step 3: Store tooltip info
    $targetLayer->tooltip_on = $tooltip_on;
    $targetLayer->tooltip = $tooltip;
    if (isset($_REQUEST['properties_only'])) {
        return;
    }
    // Step 4: Store the colorscheme info
    $classification = $layerProperties->classification;
    if ($classification) {
        /* @var $colorscheme ColorScheme */
        $colorscheme = $targetLayer->colorscheme;
        if ($isDefault) {
            $targetLayer->colorschemetype = $projectLayer->colorschemetype;
            $classification['type'] = $projectLayer->colorschemetype;
        } else {
            $targetLayer->colorschemetype = (! is_null($layerProperties->colorscheme)) ? 'custom' : (string) $classification['type'];
        }
        
        if (preg_match('/^[0123456789ABCDEF]{6}$/', (string) $classification['stroke_color']))
            $classification['stroke_color'] = '#' . $classification['stroke'];
        if (preg_match('/^[0123456789ABCDEF]{6}$/', (string) $classification['fill_color']))
            $classification['fill_color'] = '#' . $classification['fill'];
            /* @var $targetLayer Layer */
        
        $targetLayer->colorschemecolumn = $column = (string) $classification['attribute'];
        $targetLayer->colorschemestroke = $stroke = (string) $classification['stroke'];
        $targetLayer->colorschemefill = $fill = (string) $classification['fill'];
        $targetLayer->colorschemesysmbol = $symbol = (string) $classification['symbol'];
        $targetLayer->colorschemesymbolsize = $size = (string) $classification['symbol_size'];
        
        global $SYMBOLSIZEMAP;
        $rules = $layerProperties->colorscheme->xpath('//rule');
        
        $ruleset = ($isDefault) ? $projectLayer->colorscheme->getAllEntries() : $rules;
        
        // Step 5: Save the rules if present
        if (count($ruleset)) {
            $colorscheme->clearScheme();
            foreach ($ruleset as $rule) {
                
                $rule = $isDefault ? $rule : $rule->attributes();
                
                if ($isDefault) {
                   // System::GetDB()->debug=true;
                    $entry = $colorscheme->addEntry();
                    $entry->priority = $rule->priority;
                    $entry->fill_color = $rule->fill_color;
                    $entry->stroke_color = $rule->stroke_color;
                    $entry->criteria1 = $rule->criteria1;
                    $entry->criteria2 = $rule->criteria2;
                    $entry->criteria3 = $rule->criteria3;
                    $entry->symbol = $rule->symbol;
                    $entry->symbol_size = $rule->symbol_size;
                    $entry->description = $rule->description;
                    $entry->label_style = $rule->label_style_string;
                    
                } else {
                    if (preg_match('/^[0123456789ABCDEFabcdef]{6}$/', (string) $rule['stroke']))
                        $rule['stroke'] = '#' . $rule['stroke'];
                    if (preg_match('/^[0123456789ABCDEFabcdef]{6}$/', $rule['fill']))
                        $rule['fill'] = '#' . $rule['fill'];
                    $entry = $colorscheme->addEntry();
                    $entry->priority = '' . $rule['priority'];
                    $entry->fill_color = '' . $rule['fill'];
                    $entry->stroke_color = '' . $rule['stroke'];
                    $entry->criteria1 = '' . $rule['field'];
                    $entry->criteria2 = '' . $rule['operator'];
                    $entry->criteria3 = '' . $rule['value'];
                    $entry->symbol = '' . $rule['symbol'];
                    $entry->symbol_size = (string) $rule['size'];
                    if (isset($rule['description']))
                        $entry->description = (string) $rule['description'];
                    $entry->label_style = $rule['label_style'];
                }
                // $entry->description =(trim($description)!=='') ? $description : "{$rule['field']} {$rule['operator']} {$rule['value']}";
            }
        }
        $type = (string) $classification['type'];
        
        if ($type != 'custom') {
            
            $colorscheme->clearScheme();
            // fetch the permissions and embed status being used for this call
            list ($embedded, $permission) = $projInfo['project']->checkBrowserPermission($user, $request, $_SERVER);
            if ($permission < AccessLevels::EDIT)
                return denied(DENIED_NEEDEDIT);
            
            if ($type != 'single')
                list ($palettename, $palettenumber, $palettetype) = explode('_', $fill);
            
            switch ($type) {
                case 'single':
                    $targetLayer->colorscheme->setSchemeToSingle($fill, $stroke, $symbol, $size);
                    break;
                case 'equalinterval':
                    $targetLayer->colorscheme->setSchemeToEqualInterval($column, $palettetype, $palettenumber, $palettename, $stroke, $symbol, $size);
                    break;
                case 'quantile':
                    $targetLayer->colorscheme->setSchemeToQuantile($column, $palettetype, $palettenumber, $palettename, $stroke, $symbol, $size);
                    break;
                case 'unique':
                    $targetLayer->colorscheme->setSchemeToUnique($column, $palettenumber, $palettename, $stroke, $symbol, $size);
                    break;
            }
        }
    }
    /* @var $formatter ProjectLayerFormatter */
    
    $formatter = new ProjectLayerFormatter($world, $user);
#	var_dump($projectLayer);
#die();
    $formatter->WriteXML($projectLayer);
    
    /*
     * $colorscheme = $targetLayer->colorscheme; $ruleset = $colorscheme->getAllEntries(); $layerProperties->addChild('colorscheme'); $layerProperties = $layerProperties->asXML(); $layerProperties= explode('<colorscheme/>',$layerProperties); echo $layerProperties[0]; /*echo "<colorscheme>"; foreach( $ruleset as $rule) { echo "\n\t\t".$rule->toXML(); } echo "\n\t</colorscheme>\n";
     */
    // echo $layerProperties[1];*/
}
?>
